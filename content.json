{"meta":{"title":"猪头日记","subtitle":"","description":"","author":"Zhechao Nian","url":"https://nianzhechao.github.io","root":"/"},"pages":[],"posts":[{"title":"性能测试环境数据准备指南","slug":"性能测试环境数据准备指南","date":"2022-03-24T12:27:41.000Z","updated":"2025-01-08T08:09:02.660Z","comments":true,"path":"2022/03/24/性能测试环境数据准备指南/","link":"","permalink":"https://nianzhechao.github.io/2022/03/24/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87%E6%8C%87%E5%8D%97/","excerpt":"","text":"概述 本文数据库使用 Oracle 一般来讲，测试团队的性能测试环境会和功能测试环境区分开来。功能测试环境迭代速度比较快，一般开发改完缺陷之后当天就要验证，每天都会升级很多次；而性能测试环境不需要具备完整的功能，如果是测数据库性能的话，用接口或者直接跑SQL脚本，都可以实现性能监控的目的。 功能测试环境的数据一般会和生产环境比较类似，至少数据类型一般都可以对应得上，如果要搭建性能测试环境的话，也是从功能测试环境数据库的基础上进行翻倍（我们叫翻库），做一些假数据出来。 思路那就很简单了，只要主键不冲突，按照原有的数据，做一些小的修改再插回去就好了。 我们假设有这样一个表，里面只有一年的数据，是从生产环境脱敏过后拿过来测试用的，那如果测功能的话肯定完全够用了，但是我们想翻成类似生产环境的数据量大小，拿来做性能测试，这怎么搞呢？ 简单写下SQL的思路： 1234567891011121314151617CREATE TABLE TABLE_A_BACKUP AS SELECT * FROM TABLE_A-- 比较怂的同学记得备份一下INSERT INTO TABLE_A( P_CODE, T_DATE, A_TYPE, ...)SELECTA.P_CODE,to_char( to_date( A.T_DATE, &#x27;yyyy-mm-dd&#x27; ) + 365, &#x27;yyyy-mm-dd&#x27; ) T_DATE,A.A_TYPE,...FROM TABLE_A A WHERE to_date( A.T_DATE, &#x27;yyyy-mm-dd&#x27; ) &gt;= to_date( &#x27;2018-01-01&#x27;, &#x27;yyyy-mm-dd&#x27; ) AND to_date( A.T_DATE, &#x27;yyyy-mm-dd&#x27; ) &lt;= to_date( &#x27;2018-12-31&#x27;, &#x27;yyyy-mm-dd&#x27; ); 这段就是把一年的数据翻成两年，加上365天再插回去（2020年是闰年，366天，翻到那里别忘了），当然这只适用于时间信息作为主键的库，不过大多数库都有个时间戳之类的东西。这段SQL写起来还是很简单的哈。 那如果说，我们有个信息表，里面没有时间字段，或者时间字段没拿来当主键，怎么办？ 一般来说，这种信息表都会有个编号，比如学生学号啊、商品编码之类的，这种东西设计来当主键（之一）再合适不过，并且这种东西的位数一般是固定的。既然是测试环境，那我们干脆狂野一点，管他什么位数，我直接在你位数后面再拼上去一位，看你怎么重复。（这样也方便区分哪些是你翻出来的数据，哪些是之前就有的数据） SQL如下： 1234567891011121314INSERT INTO TABLE_A( P_CODE, T_DATE, A_TYPE, ...)SELECTA.P_CODE || &#x27;A&#x27;,A.T_DATE,A.A_TYPE,...FROM TABLE_A A WHERE to_date( A.t_date, &#x27;yyyy-mm-dd&#x27; ) &gt;= to_date( &#x27;2018-01-01&#x27;, &#x27;yyyy-mm-dd&#x27; ) AND to_date( A.t_date, &#x27;yyyy-mm-dd&#x27; ) &lt;= to_date( &#x27;2018-12-31&#x27;, &#x27;yyyy-mm-dd&#x27; ); 这段就是把2018年的数据给翻了一倍，新翻出来的数据的P_CODE后面都有个字符A，如果想删掉就用 1DELETE FROM TABLE_A WHERE P_CODE LIKE &#x27;%A&#x27;; 就好了。（前提是你拼之前没有以A结尾的P_CODE哈） 基本的翻库方法就这么两种，数据更复杂的话就两种拼起来一起用。 后记其实在翻库过程中还会出现比较复杂的情况，比如时间均匀地分布在每一年，P_CODE翻倍了数据量还是不够，我心想这搞个锤子，就搜啊搜，搜到个忽略主键冲突的hint，是这么写的 12INSERT /*+IGNORE_ROW_ON_DUPKEY_INEX(表名(字段名))*/ INTO 表名-- 后面不变 大概意思就是，你把表名和想要忽略的主键字段名，写在这一大段里面，插入的时候如果遇到主键冲突，它就回退到上一次插入，然后把冲突的这一次跳过，继续跑后面的，类似mySQL的INSERT IGNORE。我一看到还有这种写法直接惊了，这他娘的爽啊，我复制粘贴过来就是一顿乱插，结果立马报错~ 1ORA-00600: 内部错误代码, 参数:[qcsgpvc3],[],[],[],[],[],[],[],[],[],[],[] 网上的解决方案也很多，稍微研究了一下感觉有点麻烦，本着敏捷开发的原则（懒），就直接把主键冲突的数据给删了，看你再报错。（这种懒比行为在造测试环境数据的时候可以干，记得备份一下就好） 还有就是某天晚上直接跑了3500万条数据的翻倍，心想明天起来就是七千万条，爽死，结果醒来看到一条报错： 1ORA-01555：snapshot too old 妈的，一晚上白跑。搜了一下发现是UNDO表不够用产生的，简单讲就是数据跑的太多了，建议优化一下。干脆分时间段，一点一点跑~","categories":[],"tags":[]},{"title":"hexo博客写作指南","slug":"hexo博客写作指南","date":"2022-03-01T13:17:43.000Z","updated":"2025-01-08T08:09:02.629Z","comments":true,"path":"2022/03/01/hexo博客写作指南/","link":"","permalink":"https://nianzhechao.github.io/2022/03/01/hexo%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/","excerpt":"","text":"初始化见hexo官方文档 配置文件配置文件优先级博客文件夹根目录下的_config.yml可以用来修改大部分配置，主题目录下也有该文件，其优先级为：hexo配置文件中的theme_config -&gt; _config.[theme].yml -&gt; 位于主题目录下的 _config.yml。将所有主题配置集中在一处是推荐的做法。 配置文件内容根目录下_config.yml中的theme: XXX，修改该值可以简单地切换主题（需要在博客根目录安装主题）。 其他的还是看官方文档好了，或者直接进去看英文都能看得懂的。 写文章12hexo n[ew] [layout] &lt;title&gt;# 使用该命令创建一个新的页面 创建出的新页面会在source/_posts路径下，md文件即是文章正文 1234hexo generatehexo deploy# 生成静态文件并发布# 或者可以直接简写为 hexo d -g","categories":[],"tags":[]}],"categories":[],"tags":[]}